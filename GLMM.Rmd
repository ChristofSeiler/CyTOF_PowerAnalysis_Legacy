---
title: "Power Analysis for CyTOF Experiments"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load Packages

```{r}
library(MCMCpack)
library(mvtnorm)
library(magrittr)
library(stringr)
library(STRINGdb)
library(ggplot2)
library(GGally)
library(lme4)
library(mbest)
library(BDgraph)
library(parallel)
n_cores = 16
```

## Goal

Power is the probability that an estimated treatment effect is statistically significantly positive. The goal is to evaluate power as a function of the sample size.

## Prior Information on Protein-Protein Interaction

We can use the protein-protein interaction database [STRING](http://string-db.org/) to set ``Sigma``. Download proteins for human species (code is 9606). Consider interaciton that are 0.9 confidence. From the STRING website: In STRING, each protein-protein interaction is annotated with one or more 'scores'. Importantly, these scores do not indicate the strength or the specificity of the interaction. Instead, they are indicators of confidence, i.e. how likely STRING judges an interaction to be true, given the available evidence. All scores rank from 0 to 1, with 1 being the highest possible confidence. A score of 0.5 would indicate that roughly every second interaction might be erroneous (i.e., a false positive).

```{r}
markers = read.csv("markers.csv",stringsAsFactors = FALSE)
markers
p = nrow(markers)
p
```

Retrieve interactions from server.

```{r}
string_db = STRINGdb$new(version="10", species=9606, score_threshold=900, input_directory="")
markers_mapped = string_db$map(markers, "gene_nk", removeUnmappedRows = FALSE)
head(markers_mapped)
interactions = string_db$get_interactions(markers_mapped$STRING_id)
interactions = data.frame(from = interactions$from,
                          to = interactions$to,
                          combined_score = interactions$combined_score)
interactions
from_id = sapply(as.character(interactions$from),function(string_id) {
  str_detect(string_id,markers_mapped$STRING_id) %>% which
})
to_id = sapply(as.character(interactions$to),function(string_id) {
  str_detect(string_id,markers_mapped$STRING_id) %>% which
})
interactions = data.frame(interactions,from_id,to_id)
head(interactions)
adj_g = matrix(0,nrow = p,ncol = p)
for(i in 1:nrow(interactions)) {
  edge = interactions[i,]
  adj_g[edge$from_id,edge$to_id] = 1
}
```

How does the covariance structure derived from STRING look like?

```{r}
InvSigma = rgwish(n = 1,adj.g = adj_g,b = 3)[,,1]
Sigma = chol2inv(chol(InvSigma))
colnames(Sigma) = rownames(Sigma) = markers$protein_nk
X = rmvnorm(n = 10000,sigma = Sigma)
colnames(X) = markers$protein_nk
ggcorr(X)
```

## Fit Model and Calculate Power

One of the key paramters is the Intraclass Correlation Coefficient (ICC):

$$ \text{ICC} = \frac{\sigma_{\text{donor}}}{\sigma_{\text{donor}} + \sigma_{\text{cell}}} $$

We use the multivariate generalization of ICC introduced by Yue et al. 2015[^1].

```{r}
fake_data = function(n_donors) {
  # experimental design
  #n_donors = 30
  n_cells = 1000
  donor = rep (1:n_donors, each=n_cells)
  status = rep(c( rep(-.5,n_cells),rep(.5,n_cells)),n_donors)
  # effect size
  ICC = 0.5
  sd_donor = sum(diag(Sigma))/p * ICC/(1-ICC)
  shift_cell = rep(0,p)
  select_markers = sapply(c("PD1","Granzyme_B","CD19"),function(name) {
    str_detect(name,colnames(Sigma)) %>% which
  })
  shift_cell[select_markers] = 2*sd_donor
  #sd_cell = 1
  #ICC = sd_donor/(sd_donor+sd_cell)
  #ICC
  # donor level
  explanatory_donor = NULL
  for(j in 1:n_donors) {
    #explanatory_donor[j] = rnorm(n = 1,
    #                             mean = 0,
    #                             sd = sd_donor)
    explanatory_donor[[j]] = rmvnorm(n = 1,
                                     mean = rep(0,p),
                                     sigma = sd_donor*diag(p)) %>% c
  }
  # cell level
  explanatory = NULL
  for(i in 1:(n_donors*n_cells)) {
    #explanatory[i] = rnorm(n = 1,
    #                       mean = status[i]*shift_cell + explanatory_donor[donor[i]],
    #                       sd = sd_cell)
    explanatory[[i]] = rmvnorm(n = 1,
                               mean = ( status[i]*shift_cell + explanatory_donor[[donor[i]]] ) %>% c,
                               sigma = Sigma)
  }
  df_explanatory = do.call(rbind,explanatory) %>% data.frame
  names(df_explanatory) = colnames(Sigma)
  data.frame(status = factor(status,labels = c("LTNP","CP")),
             df_explanatory,
             donor = factor(donor))
}
test = fake_data(10)
ggplot(test, aes(status,PD1,color = donor)) + geom_boxplot()
ggplot(test, aes(status,Granzyme_B,color = donor)) + geom_boxplot()
ggplot(test, aes(status,CD19,color = donor)) + geom_boxplot()
ggplot(test, aes(status,NTB_A,color = donor)) + geom_boxplot()
```

Power analysis for Generalized Linear Models (GLMs) without random effects.

```{r}
alpha = 0.05
n_sim = 10
Ns = c(15,30)
markers_str = paste(colnames(Sigma),collapse = " + ")
power_glm = function(n_donors) {
  sink("progress.log")
  power = mclapply(1:n_sim,function(i) {
    cat(".")
    test = fake_data(n_donors)
    formula = as.formula( paste("status ~ ",markers_str) )
    res_glm = glm(formula,family = binomial(link='logit'), data = test)
    pvalues = summary(res_glm)$coefficients[-1,4]
    mean(p.adjust(pvalues,method = "BH") < alpha)
    }, mc.cores = n_cores) %>% simplify2array
  sink()
  mean(power)
}
power = sapply(Ns,power_glm)
ggplot(data.frame(Ns,power),aes(Ns,power)) + 
  geom_line() + geom_point() + 
  labs(title = "GLM") + 
  geom_hline(yintercept = alpha,color = "red")
```

Power analysis for Generalized Linear Mixed Models (GLMM) with random effects.

```{r}
power_glmm = function(n_donors) {
  sink("progress.log")
  power = mclapply(1:n_sim,function(i) {
    cat(".")
    test = fake_data(n_donors)
    formula_expr = parse(text = paste0("mhglm(",
                              paste("status ~",markers_str,"+",paste0("(",markers_str," | donor),")),
                              "family = binomial(link='logit'),",
                              "data = test,",
                              "control = mhglm.control(parallel = FALSE,fit.method = 'firthglm.fit'))"))
    res_glm = eval(formula_expr)
    pvalues = summary(res_glm)$coefficients[-1,4]
    mean(p.adjust(pvalues,method = "BH") < alpha)
  }, mc.cores = n_cores) %>% simplify2array
  sink()
  mean(power)
}
power = sapply(Ns,power_glmm)
ggplot(data.frame(Ns,power),aes(Ns,power)) + 
  geom_line() + geom_point() + 
  labs(title = "GLMM") + 
  geom_hline(yintercept = alpha,color = "red")
```

## Session Info

```{r}
sessionInfo()
```

[^1]: Yue et al. (2015). Estimating a graphical intra-class correlation coefficient (GICC) using multivariate probit-linear mixed models
